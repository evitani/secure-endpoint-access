# About Secure Endpoint Access

## Introduction
Secure Endpoint Access (SEA) is a protocol for creating and maintaining a protected channel between a client application and a remote service over which JSON-encoded data can be sent. It defines key exchange, encryption, and message integrity verification processes that protect against a variety of attack vectors.

The protocol is designed to deliver high levels of security and usability in a variety of scenarios. It supports two modes: content protection, which secures request and response content; and encapsulation, which additionally secures metadata about requests such as URL parameters and methods.

## Why not just use TLS?

SEA is designed to compliment existing security techniques such as TLS, not replace them. It addresses exploits of some of these techniques, such as TLS Inspection, which are designed to break the security chain and view unencrypted data passing over networks. In addition, it allows communications to pass through intermediary servers – such as applications passing data to a single gateway server which routes them to their final destination – without allowing said server from viewing, modifying, or replaying requests.

TLS implementations that protect against inspection enter a fail state when such techniques are detected. This is important in maintaining the security of the protocol, but leaves the client unable to interact with the service. Clients experiencing this will usually break, sometimes with no user support. SEA is therefore designed to secure communications in a way that does not rely on a strictly-enforced TLS connection. This means that SEA-secured applications can continue to function securely even where TLS Inspection is detected.

## TLS Inspection
TLS Inspection is an integral part of the security posture for many corporate networks. It breaks the secure connection between a client and service, allowing a security application to read the content of requests. This protects against attackers who hide malicious content in secure requests, but at the expense of decrypting and scanning other traffic.

It is considered good practice for any network that implements TLS Inspection to manually whitelist certain connections, avoiding TLS Inspection to protect sensitive traffic from being read. However, this requires an active step to be taken by administrators of any such network, a step that may not be understood by those encouraging the use of services which expose sensitive information.

TLS Inspection can, therefore, result in network administrators collecting sensitive data about their users, including information that may breach the rights of their users. The technique is most common in corporate environments, where tracking access to content or tools relating to topics such as health may breach the employment rights of users.


## Man-in-the-Middle Attacks
TLS Inspection is a form of Man-in-the-Middle (MitM) attack, and any protocol must therefore also consider other forms of such exploit. SEA balances this need for integrity management with the reality of client-side application delivery: many client applications are delivered to users in a way that their underlying code can be inspected. Because of this, an attacker who is capable of implementing a MitM attack should find it trivial to access any secret embedded within a client application's code. As such, SEA does not rely on client applications use of a pre-generated secret.

Service-side secrets are implemented, however, to sign responses in a way that allows client applications to verify their integrity. This integrity check allows client applications to reject secure responses that have not been directly generated by the service. By doing this as part of the initial handshake, MitM attacks against SEA-secured communications will be detected before any sensitive data is passed.

_NB: Because SEA is designed to work in environments where the source code of all client applications is assumed to be compromised, it does not work as a protocol for validating the source of a client connection. Once the handshake is completed, the channel is secure even if the client is malicious. If the veracity of a client application is important, ensure you implement suitable protocols to detect impersonation._

## Replay Attacks
Communication chains that involve a third party – one who is neither the authenticated user nor the final service – are susceptible to replay attacks. These allow the third party to selectively store a request or response before "replaying" it the relevant system at an opportune time. This allows the attacker to change the context of the original packet, performing authenticated actions without the user being present, or making them believe a service behaved differently to reality.

Replay attacks can be malicious, or they can be inadvertently caused by an under-performing or misconfigured intermediary. In either case, mistimed or repeated requests can be dangerous: they undermine the validity of any audit logs, introduce risk into handling mission-critical instructions, and make fraud difficult to detect. Protecting against replay attacks is, therefore, important in securing any client-service communication.