# Establishing Trust

Trust is established by a client-initiated handshake. To begin, the client must generate a new encryption [Client Encryption Pair](Terms-Entities.md#client-encryption-pair), the Client Encryption Secret Key (CESK) and Client Encryption Public Key (CEPK). These are generated using the ECDH X25519 curve and stored for the length of the secured session. The CESK and CEPK must never be re-used between sessions, and the CESK must never be transmitted.

Following generation of the CESK and CEPK, the client initiates the handshake:

`GET /sea-trust/<Client ID>/<Client Encryption Public Key>/<time>`

The `time` parameter will be the current time according to the client, expressed as an integer value of whole seconds passed since 1970-01-01T00:00:00 (a UNIX timestamp).

On receipt, the service will check its own current time, and compare this to the value sent by the client. A new session will be begun, identified by a [Session ID](Terms-Entities.md#session-id), and the difference between times – the [Time Offset](Terms-Entities.md#time-offset) – will be stored against the session.

Next, the service will generate a [Service Encryption Pair](Terms-Entities.md#service-encryption-pair) – a Service Encryption Secret Key (SESK) and Service Encryption Public Key (SEPK) – in the format as the Client Encryption Pair. The pair will be stored against the session.

The service will then compute the [Traffic Encryption Key](Terms-Entities.md#traffic-encryption-key) (TEK) using the SESK, the CEPK, and ECDH X25519. The TEK is stored for future use against the Session ID, but never transmitted. A new [Timed Verification Key](Terms-Entities.md#timed-verification-key) (TVK) – a 16-character alphanumeric string – is generated randomly, and this is additionally saved against the session.

Finally, the Verification Challenge (VC) string is generated by combining the TVK, the Session ID, and a random 128-character alphanumeric string, then encrypted using AES-256-CBC. The service will then return a JSON-encoded body:

```json
{
  "sid": "<Session ID>",
  "sepk": "<Service Encryption Public Key>",
  "vc": "<VC>",
  "vc_signature": ["<VC Signature>"],
  "adp": "<Accepted Dormancy Period>",
  "supports": ["content", "encapsulation"]
}

```
The `supports` parameter will contain an array with at least one item, listing the variants of the SEA protocol (currently `content`, `encapsulation`, or both) supported by the service.

The `vc_signature` will be an array, containing the result of signing the Verification Challenge with the SVSK, represented as a base64-encoded string. The client will validate this signature using the SVPK and, if the verification fails, it will [destroy trust](Destroying-Trust.md) and end the process of establishing trust. After destroying trust for this reason, the client may automatically retry the process one additional time. A second failure must require user interaction to trigger additional retries.

_NB: [During Service Verification Pair Rotation](Service-Verification-Pair-Rotation.md), the `vc_signature` array may contain two strings which should be handled as described in the rotation process._

If signature validation occurs successfully, the client then computes the TEK using the CESK, the SEPK, and ECDH X25519. The TEK is stored locally for use, and never transmitted. Following computation of the TEK, the client decrypts the Verification Challenge, extracts and stores the TVK, and confirms the Session ID matches that in the payload. If it does not, then trust is destroyed as above.

On successful verification of the Session ID within the Verification Challenge, trust has been established between the client and the service. 

## Errors

The `/sea-trust` endpoint may respond with one of the following error codes if it detects a failure state:

* `400 Malformed Request` will be returned if one or more of the URL parameters is missing or badly formatted
* `400 Invalid Key` will be returned if the CEPK does not represent an ECDH X25519 public key

In addition, any implementations that implement specific logic based on the provided Client ID may return `400 Invalid Client ID` should the provided value not meet the requirements of the implementation.